// main.c - PIC16F1788 - MPLAB X v6.20
// Perfect retention + sends RAW 16-bit binary ADC value (2 bytes, big-endian)


#include <xc.h>
#include "mcc_generated_files/system/system.h"
#include "mcc_generated_files/adc/adc.h"
#include "mcc_generated_files/adc/adc.h"

//#include "mcc_generated_files/peripheral/adc.h"

void EUSART_Write(uint8_t data);   // Already generated by MCC

void main(void)
{
   
    static uint16_t last_adc_value = 0;   // Holds last valid reading

    SYSTEM_Initialize();
    __delay_ms(100);

    // Start first conversion
    ADCON0bits.CHS = 0;       // AN0
    __delay_us(5);
    ADCON0bits.GO = 1;

    while (1)
    {
        // 1. Send "Hello World!\r\n" in normal ASCII (optional - remove if you want 100% binary only)
        const char msg[] = "$";
        for (uint8_t i = 0; msg[i]; i++)
        {
            while (!UART.IsTxReady()) { ; }
            EUSART_Write(msg[i]);
        }

        // 2. Send the last valid ADC value as RAW BINARY (2 bytes, MSB first)
        while (!UART.IsTxReady()) { ; }
        EUSART_Write((uint8_t)(last_adc_value >> 8));     // High byte

        while (!UART.IsTxReady()) { ; }
        EUSART_Write((uint8_t)(last_adc_value & 0xFF));   // Low byte

        // 3. Check if conversion finished ? update and restart
        if (ADCON0bits.GO == 0)               // Conversion done
        {
            last_adc_value = ((uint16_t)ADRESH << 8) | ADRESL;

            __delay_us(5);                    // Acquisition time
            ADCON0bits.GO = 1;                // Start next conversion immediately
        }

        __delay_ms(100);   // Controls print rate (ADC still samples as fast as possible)
    }
}